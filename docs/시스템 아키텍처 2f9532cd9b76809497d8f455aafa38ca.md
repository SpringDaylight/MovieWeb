# 시스템 아키텍처

## 1) 시스템 아키텍처 개요

### 핵심 원칙

- **서버리스 우선(Serverless-first)**: 항상 켜둘 서버 최소화
- 벡터 검색은 OpenSearch(Vector)로 단순화
- **LLM/Embedding은 Bedrock 호출**로 처리(학습/서빙 인프라 없음)

## 2) 전체 시스템 아키텍처 다이어그램

```
[Client(Web/App)]
      |
   (HTTPS)
      v
[CloudFront]  (선택) ──> [S3 Static Hosting] (프론트 배포)
      |
      v
[API Gateway] ──> [Lambda: API Router]
      |
      +-----------------------------+
      |                             |
      v                             v
[Lambda: A-1 Preference]        [Lambda: A-5 Search]
      |                             |
      | (Bedrock LLM)               | (Bedrock Embedding)
      v                             v
[User Preference JSON]          [OpenSearch Vector kNN]
      |                             |
      +--------------+--------------+
                     v
             [Lambda: A-3 Predictor]
                     |
                     v
             [Lambda: A-4 Explainer]
                     |
               (Bedrock LLM)
                     v
               [Response JSON]
                     |
                     v
                  Client

----------------------- Data Stores -----------------------
[DynamoDB]  : 사용자 세션/취향 벡터/예측 결과 캐시
[OpenSearch]: 영화 벡터 인덱스(임베딩), 메타데이터 ID
[S3]        : 원천/가공 영화 데이터, 로그/리포트 산출물

--------------------- Batch Pipeline ----------------------
[EventBridge(Cron)]
      |
      v
[Step Functions]  (선택: 배치 오케스트레이션)
      |
      +--> [Lambda/ECS Fargate: Collect Movies] --> S3(raw)
      |
      +--> [ECS Fargate: A-2 Vectorize]
              | (Bedrock LLM 요약 + Embedding)
              v
           OpenSearch (index upsert)
```

---

## 3) 구성요소별 “역할 + AWS 서비스” (구체)

### A) 프론트엔드

- **S3 정적 호스팅** + (선택) **CloudFront CDN**
- 목적: 배포/비용/운영 단순화

### B) API 계층

- **API Gateway**
    - `/analyze/preference` (A-1)
    - `/search/emotional` (A-5)
    - `/predict/satisfaction` (A-3)
    - `/explain` (A-4)
    - `/group/simulate` (A-6)
- **Lambda**
    - 요청 라우팅 + 간단 검증 + 서비스 호출 오케스트레이션

### C) LLM/Embedding 계층

- **Amazon Bedrock**
    - A-1: 사용자 텍스트 → 취향 JSON 추출(LLM)
    - A-2: 영화 텍스트 → 정서/서사 요약(LLM) + 임베딩(Embedding)
    - A-4: 예측값/근거 → 자연어 설명(LLM)
    - A-5: 검색 질의 임베딩(Embedding)

### D) 벡터 검색

- **Amazon OpenSearch Service (Vector/kNN)**
    - 영화 임베딩 인덱스
    - 검색(A-5) 후보 Top-K 생성
    - (선택) A-3에서 유사영화 기반 보조 피처에도 활용

### E) 상태/캐시/결과 저장

- **DynamoDB**
    - `UserProfile`: 사용자 취향 벡터(JSON), 페르소나 코드(선택)
    - `PredictionCache`: (user_id, movie_id) → 확률/설명 캐시
    - `GroupSession`: 그룹 구성원/합성 결과

### F) 배치 파이프라인(영화 DB 구축)

- **EventBridge(Cron)**: “매일 새벽 2시” 같은 주기 실행
- **ECS Fargate**: A-2 벡터화 워커(영화 N편 처리)
- (선택) **Step Functions**: 수집→정제→벡터화 단계 관리(실패 재시도/모니터링)

### G) 운영/보안/관측

- **CloudWatch Logs/Metrics**: Lambda/ECS 로그 및 지표
- **IAM**: 최소권한 원칙(특히 Bedrock/OpenSearch 접근)
- **Secrets Manager / SSM Parameter Store**: TMDB 키 등 비밀 관리
- (선택) **WAF**: API 남용 방지(데모 외부 공개 시)

---

## 4) “요청 경로”를 두 가지로 나눠서 이해하면 쉬움

### 4-1) 온라인 경로(사용자 요청 처리)

1. Client → API Gateway
2. Lambda가 A-1(A-5) 필요 여부 분기
3. Bedrock(OpenSearch) 호출
4. A-3 확률 계산 → A-4 설명 생성
5. DynamoDB 캐시 저장 → 응답 반환

### 4-2) 오프라인 경로(영화 벡터 DB 구축)

1. EventBridge 트리거
2. 수집(메타/줄거리) → S3 저장
3. ECS Fargate가 영화별 요약/임베딩
4. OpenSearch 인덱스 업데이트

---

## 5) MVP에서 “이 정도면 충분”한 이유 (현실 기준)

- **EKS 같은 무거운 플랫폼 없이도**
    
    프론트/백/API/데이터/ML(추론)/DevOps(배포·모니터링) 모두 포함 가능
    
- 비용/운영 리스크가 낮고, 3주에 맞는 속도

---

## 6) (선택) EKS를 꼭 넣어야 한다면?

교과/심사 요구로 “쿠버네티스가 반드시 들어가야 한다”면,

- **API 서버 1개 + 배치 워커 1개만 EKS에 올리고**
- 나머지(Bedrock/OpenSearch/S3/DynamoDB)는 그대로 쓰는 **하이브리드**가 가장 안전함.

하지만 **3주/토큰 제한/팀 비전공자 포함** 조건이면,

우선은 위의 **Serverless + Fargate** 구성이 성공 확률이 높다.